initSidebarItems({"enum":[["AbiKind",""],["AttrStyle","Distinguishes between Attributes that decorate items and Attributes that are contained as statements within items. These two cases need to be distinguished for pretty-printing."],["BareFnArgName","Names of arguments in the `BareFnArg` structure"],["BinOp",""],["BindingMode",""],["Body","Body of a derived struct or enum."],["CaptureBy","A capture clause"],["Constness",""],["Defaultness",""],["ExprKind",""],["FnArg","An argument in a function header."],["ForeignItemKind","An item within an `extern` block"],["FunctionRetTy",""],["ImplItemKind",""],["ImplPolarity",""],["InPlaceKind",""],["ItemKind",""],["LitKind",""],["MacStmtStyle","How a macro was invoked."],["MetaItem","A compile-time attribute item."],["Mutability",""],["NestedMetaItem","Possible values inside of compile-time attribute lists."],["Pat",""],["PathParameters","Parameters of a path segment."],["RangeLimits","Limit types of a range (inclusive or exclusive)"],["Stmt","A statement, usually ending in a semicolon."],["TraitBoundModifier","A modifier on a bound, currently this is only used for `?Sized`, where the modifier is `Maybe`. Negative bounds should also be handled here."],["TraitItemKind",""],["Ty","The different kinds of types recognized by the compiler"],["TyParamBound","The AST represents all type param bounds as types. `typeck::collect::compute_bounds` matches these against the \"special\" built-in traits (see `middle::lang_items`) and detects Copy, Send and Sync."],["UnOp",""],["Unsafety",""],["VariantData","Data stored within an enum variant or struct."],["ViewPath",""],["Visibility","Visibility level of an item."],["WherePredicate","A single predicate in a `where` clause"]],"fn":[["parse","Parse tokens of source code into the chosen syn data type."],["parse_file","Parse the content of a file of Rust code."],["parse_str","Parse a string of Rust code into the chosen syn data type."],["parse_tokens","Parse a `quote::Tokens` of Rust code into the chosen syn data type."]],"mod":[["delimited",""],["fold","A Folder represents an AST->AST fold; it accepts an AST piece, and returns a piece of the same type."],["tokens","Discrete tokens that can be parsed out by synom."]],"struct":[["Abi",""],["AngleBracketedParameterData","A path like `Foo<'a, T>`"],["ArgCaptured",""],["ArgSelf",""],["ArgSelfRef",""],["Arm","An arm of a 'match'."],["Attribute","Doc-comments are promoted to attributes that have `is_sugared_doc` = true"],["BareFnArg","An argument in a function type."],["BareFnTy",""],["Block","A Block (`{ .. }`)."],["BodyEnum","It's an enum."],["BodyStruct","It's a struct."],["BoundLifetimes","A set of bound lifetimes, e.g. `for<'a, 'b, 'c>`"],["DeriveInput","Struct or enum sent to a `proc_macro_derive` macro."],["Expr","An expression."],["ExprAddrOf","A referencing operation (`&a` or `&mut a`)"],["ExprArray","An array, e.g. `[a, b, c, d]`."],["ExprAssign","An assignment (`a = foo()`)"],["ExprAssignOp","An assignment with an operator"],["ExprBinary","A binary operation, e.g. `a + b`, `a * b`."],["ExprBlock","A block (`{ ... }` or `unsafe { ... }`)"],["ExprBox","A `box x` expression."],["ExprBreak","A `break`, with an optional label to break, and an optional expression"],["ExprCall","A function call."],["ExprCast","A cast, e.g. `foo as f64`."],["ExprCatch","A catch expression."],["ExprClosure","A closure (for example, `move |a, b, c| a + b + c`)"],["ExprContinue","A `continue`, with an optional label"],["ExprField","Access of a named struct field (`obj.foo`)"],["ExprForLoop","A for loop, with an optional label."],["ExprGroup","No-op: used solely so we can pretty-print faithfully"],["ExprIf","An `if` block, with an optional else block"],["ExprIfLet","An `if let` expression with an optional else block"],["ExprInPlace","E.g. 'place <- val' or `in place { val }`."],["ExprIndex","An indexing operation (`foo[2]`)"],["ExprLoop","Conditionless loop with an optional label."],["ExprMatch","A `match` block."],["ExprMethodCall","A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)"],["ExprParen","No-op: used solely so we can pretty-print faithfully"],["ExprPath","Variable reference, possibly containing `::` and/or type parameters, e.g. foo::bar::."],["ExprRange","A range (`1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`)"],["ExprRepeat","An array literal constructed from one repeated element."],["ExprRet","A `return`, with an optional value to be returned"],["ExprStruct","A struct literal expression."],["ExprTry","`expr?`"],["ExprTup","A tuple, e.g. `(a, b, c, d)`."],["ExprTupField","Access of an unnamed field of a struct or tuple-struct"],["ExprType","A type ascription, e.g. `foo: f64`."],["ExprUnary","A unary operation, e.g. `!x`, `*x`."],["ExprWhile","A while loop, with an optional label"],["ExprWhileLet","A while-let loop, with an optional label."],["ExprYield","A yield expression."],["Field","A field of a struct or enum variant."],["FieldPat","A single field in a struct pattern"],["FieldValue","A field-value pair in a struct literal."],["File",""],["FnDecl","Header (not the body) of a function declaration."],["ForeignItem",""],["ForeignItemFn","A foreign function"],["ForeignItemStatic","A foreign static item (`static ext: u8`)"],["Generics","Represents lifetimes and type parameters attached to a declaration of a function, enum, trait, etc."],["Ident","A word of Rust code, such as a keyword or variable name."],["ImplGenerics","Returned by `Generics::split_for_impl`."],["ImplItem",""],["ImplItemConst",""],["ImplItemMethod",""],["ImplItemType",""],["Item","Things that can appear directly inside of a module."],["ItemConst","A constant item (`const` or `pub const`)."],["ItemDefaultImpl","Default trait implementation."],["ItemEnum","An enum definition (`enum` or `pub enum`)."],["ItemExternCrate","An `extern crate` item, with optional original crate name."],["ItemFn","A function declaration (`fn` or `pub fn`)."],["ItemForeignMod","An external module (`extern` or `pub extern`)."],["ItemImpl","An implementation."],["ItemMod","A module declaration (`mod` or `pub mod`)."],["ItemStatic","A static item (`static` or `pub static`)."],["ItemStruct","A struct definition (`struct` or `pub struct`)."],["ItemTrait","A Trait declaration (`trait` or `pub trait`)."],["ItemTy","A type alias (`type` or `pub type`)."],["ItemUnion","A union definition (`union` or `pub union`)."],["ItemUse","A use declaration (`use` or `pub use`) item."],["Lifetime",""],["LifetimeDef","A lifetime definition, e.g. `'a: 'b+'c+'d`"],["Lit",""],["Local","Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`"],["Mac","Represents a macro invocation. The Path indicates which macro is being invoked, and the vector of token-trees contains the source of the macro invocation."],["MetaItemList","List meta item."],["MetaNameValue","Name-value meta item."],["MethodSig","Represents a method's signature in a trait declaration, or in an implementation."],["MutTy",""],["ParenthesizedParameterData","A path like `Foo(A,B) -> C`"],["ParseError",""],["PatBox","A `box` pattern"],["PatIdent","A `Pat::Ident` may either be a new bound variable (`ref mut binding @ OPT_SUBPATTERN`), or a unit struct/variant pattern, or a const pattern (in the last two cases the third field must be `None`). Disambiguation cannot be done with parser alone, so it happens during name resolution."],["PatLit","A literal"],["PatPath","A possibly qualified path pattern. Unquailfied path patterns `A::B::C` can legally refer to variants, structs, constants or associated constants. Quailfied path patterns `<A>::B::C`/`<A as Trait>::B::C` can only legally refer to associated constants."],["PatRange","A range pattern, e.g. `1...2`"],["PatRef","A reference pattern, e.g. `&mut (a, b)`"],["PatSlice","`[a, b, i.., y, z]` is represented as:"],["PatStruct","A struct or struct variant pattern, e.g. `Variant {x, y, ..}`. The `bool` is `true` in the presence of a `..`."],["PatTuple","A tuple pattern `(a, b)`. If the `..` pattern fragment is present, then `Option<usize>` denotes its position. 0 <= position <= subpats.len()"],["PatTupleStruct","A tuple struct/variant pattern `Variant(x, y, .., z)`. If the `..` pattern fragment is present, then `Option<usize>` denotes its position. 0 <= position <= subpats.len()"],["PatWild","Represents a wildcard pattern (`_`)"],["Path","A \"Path\" is essentially Rust's notion of a name."],["PathGlob","`foo::bar::*`"],["PathList","`foo::bar::{a, b, c}`"],["PathListItem",""],["PathSegment","A segment of a path: an identifier, an optional lifetime, and a set of types."],["PathSimple","`foo::bar::baz as quux`"],["PathTokens",""],["PolyTraitRef",""],["QSelf","The explicit Self type in a \"qualified path\". The actual path, including the trait and the associated item, is stored separately. `position` represents the index of the associated item qualified with this Self type."],["Span",""],["TokenTree",""],["TraitItem","Represents an item declaration within a trait declaration, possibly including a default implementation. A trait item is either required (meaning it doesn't have an implementation, just a signature) or provided (meaning it has a default implementation)."],["TraitItemConst",""],["TraitItemMethod",""],["TraitItemType",""],["Turbofish","Returned by `TyGenerics::as_turbofish`."],["TyArray","A fixed length array (`[T; n]`)"],["TyBareFn","A bare function (e.g. `fn(usize) -> bool`)"],["TyGenerics","Returned by `Generics::split_for_impl`."],["TyGroup","No-op: kept solely so that we can pretty-print faithfully"],["TyImplTrait","An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime."],["TyInfer","TyKind::Infer means the type should be inferred instead of it having been specified. This can appear anywhere in a type."],["TyNever","The never type (`!`)"],["TyParam","A generic type parameter, e.g. `T: Into<String>`."],["TyParen","No-op; kept solely so that we can pretty-print faithfully"],["TyPath","A path (`module::module::...::Type`), optionally \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`."],["TyPtr","A raw pointer (`*const T` or `*mut T`)"],["TyRptr","A reference (`&'a T` or `&'a mut T`)"],["TySlice","A variable-length array (`[T]`)"],["TyTraitObject","A trait object type `Bound1 + Bound2 + Bound3` where `Bound` is a trait or a lifetime."],["TyTup","A tuple (`(A, B, C, D, ...)`)"],["TypeBinding","Bind a type to an associated type: `A=Foo`."],["Variant","An enum variant."],["VisCrate","Crate-visible, i.e. `pub(crate)`."],["VisInherited","Inherited, i.e. private."],["VisPublic","Public, i.e. `pub`."],["VisRestricted","Restricted, e.g. `pub(self)` or `pub(super)` or `pub(in some::module)`."],["WhereBoundPredicate","A type binding, e.g. `for<'c> Foo: Send+Clone+'c`"],["WhereClause","A `where` clause in a definition"],["WhereEqPredicate","An equality predicate (unsupported)"],["WhereRegionPredicate","A lifetime predicate, e.g. `'a: 'b+'c`"]]});